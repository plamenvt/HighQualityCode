# Lazy initialization Pattern
2	
3	## Мотивация
4	
5	 * В много случаи се достъпват данни или създават обекти, от които или нямаме нужда веднага или никога не използваме. Този проблем се решава с така наречният шаблон за дизайн 'Lazy initialization pattern', който предотвратява излишно използване на ресурси от програмата ни.
6	 
7	## Цел
8	
9	 * Служи за  използване на данните в момента, в който имаме нужда от тях
10	
11	## Приложение
12	
13	* Пример 1:
14	
15	Нека имаме база с данни. В нея имаме таблица, която се грижи за данните на един студент в училище. Студентът има поредица от курсове, учители, домашни, изпити, оценки и т.н. Използвайки 'Entity Framework' ние имаме възможността да работим с класа 'Student' като всеки един обект от този клас ни представлява запис от базата с данни. Какво би станало ако имаме нужда от оценките на студентите. Ще издърпаме висчки данни за всеки един студент и освен оценките му ще имаме и всичката друга ненужна информация, която хем ще заеме излишна памет, хем ще забави преноса на данни заради обема си. Това би било така, ако 'Entity framework' е писан от студенти преди изпит по КПК :D Но тъй като не е, при създаването на навигационни property-та(това са полета, които сочат към други таблици - например 'курсове', 'учители') те са дефинират като 'virtual' такива и дават възможност вътрешно 'EF' да създава 'proxy' класове, които представляват основните класове(Student)и доставят данните само, когато имаме нужда от тях или с други думи, когато напишем 'currentStudent.grades' и активираме 'get'-a на полето.
16	 
17	
18	## Известни употреби
19	
20	* Entity Framework
21	* Singleton design pattern
22	* IQueryable интерфейс - позволява филтрацията да се извършва в базата с данни, след което да се материализира в RAM паметта при нуждата от данните(lazy loading)
23	
24	
25	## Имплментация 
26	
27	```
28	public class Customer
29	{
30	    public int CustomerID { get; set; }
31	    public string Name { get; set; }
32	    private IEnumerable<Order> _orders;
33	
34	    public IEnumerable<Order> Orders
35	    {
36	        get
37	        {
38	            if (_orders == null)
39	            {
40	                _orders = OrdersDatabase.GetOrders(CustomerID);
41	            }
42	            return _orders;
43	        }
44	    }
45	
46	    // Constructor
47	    public Customer(int id, string name)
48	    {
49	        CustomerID = id;
50	        Name = name;
51	    }
52	} 
53	  ```
54	
55	## Последствия
56	* Спестява използвани ресурси.
57	* Предотвратява наличието на излишна и ненужна информация
58	
59	## Сродни модели
60	* Не мисля, че има
61	
62	## Проблеми
63	
64	* Неправилното му използване. При достъпът до скромни ресурси, няма нужда излишно да усложняваме кода ни.
65	