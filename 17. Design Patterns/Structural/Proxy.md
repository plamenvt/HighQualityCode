# Structural patterns
---
### Proxy/Прокси
---
+ Обект, който се представя за друг обект, предлагайки същия интерфейс, като предоставя заместник или контейнер за даден реален обект, позволявайки контролиран достъп до него.
+ Основни видове проксита:
  * Отдалечено прокси (remote proxy): Локална репрезентация на обект, който се намира в друг процес, протичащ на отдалечена машина.
  * Виртуално прокси (virtual proxy): Kонтролиране на момента на инстанциране и инициализация на обект, заемащ много памет.
  * Защитно прокси (protection proxy): Добавя валидация и проверка на права за достъп до обект.

 Понякога се налага да достъпваме обекти, които са част от отделно приложение, друг домейн или са инсталирани в друга част на света. В такива случай трябва да се справим с логиката за комуникация между приложенията.

С цел кодът да бъде по-лесен за поддържане, както и за да бъде намален рискът за допускане на грешки, е добре логиката по същинската функционалност и тази, която се грижи за комуникацията, да бъдат разделени.

Идеята на шаблона Прокси е да бъде създаде локален модул, който имитира функционалността на истинския модул и приложението да ползва локалния модул така, както би ползвало истинския, а цялата логика по комуникацията с отдалечения модул да бъде изнесена в локалния - самото прокси.
 ### Клас диаграма
 ![alt text](https://camo.githubusercontent.com/c467942d5a8a1900af3359432d3d4bbc9545aa92/687474703a2f2f7777772e636f646570726f6a6563742e636f6d2f4b422f6172636869746563747572652f3439323539342f476f6650726f78792e6a7067 "Клас диаграма")

Компоненти:

+ Subject: Предоставя интерфейс, който ще бъде имплементиран както от проксито, така и от реалния клас, така че проксито да бъде лесно ползвано като заместител на реалния клас (RealSubject).
+ Proxy: Класът, който ще бъде използван от приложението и предоставя като интерфейс методите на Subject. Приложението използва този клас, който имплементира логиката за комуникация с RealSubject и връща получените данни към локалното приложение.
+ RealSubject: Реалният обект, който съдържа логиката за достъпване на данни/функционалност. Това е класът, който проксито имитира, предоставяйки функционлаността му за ползване от локалното приложение.

Примерен код:

```
using System;

  // MainApp test application 
  class MainApp
  {
    static void Main()
    {
      // Create proxy and request a service 
      Proxy proxy = new Proxy();
      proxy.Request();

      // Wait for user 
      Console.Read();
    }
  }

  // "Subject" 
  abstract class Subject 
  {
    public abstract void Request();    
  }

  // "RealSubject" 
  class RealSubject : Subject
  {
    public override void Request()
    {
      Console.WriteLine("Called RealSubject.Request()");
    }
  }

  // "Proxy" 
  class Proxy : Subject
  {
    RealSubject realSubject;

    public override void Request()
    {
      // Use 'lazy initialization' 
      if (realSubject == null)
      {
        realSubject = new RealSubject();
      }

      realSubject.Request();
    }  
  }
```
My GitHub page: [link](https://github.com/plamenvt/HighQualityCode/tree/master/17.%20Design%20Patterns)